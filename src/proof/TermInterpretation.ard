\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import proof.Proof
\import proof.TermModel
\import semantics.Interpretation
\import syntax.Context
\import syntax.Syntax
\import util.ArrayUtil
\import util.LogicUtil
\open Interpretation (⊧)

\func TermInterpretation {_ : Language} {c : Context} (T : Theory c) : Interpretation c \cowith
  | structure => \new Structure {
    | Universe => Quotient {Term c} (~ {ProvableEqualCongruence T})
    | fun f args => overArray args (Quotient {Term c} (~ {ProvableEqualCongruence T}))
        (in~ $ apply f __)
        (\lam d => ~-equiv {_} _ _ (inP (fcong d idp idp)))
    | rel r args => overArray args \Prop
        (\lam z => Prf' T (atomic r z))
        (\lam h' => ext (\lam (inP p) => inP (rcong (\lam i => symm (h' i)) p), \lam (inP p) => inP (rcong h' p)))
  }
  | variableValues v => in~ (var v)

  \where {
    \func overArray{_ : Language} {c : Context} {T : Theory c}
                   {n : Nat} (args : Array (Quotient {Term c} (~ {ProvableEqualCongruence T})) n)

                   (R : \Set)
                   (f : Array (Term c) n -> R)
                   (e : \Pi {x y : Array (Term c) n} (DArray (\lam (i : Fin n) => Prf T (equal (x i) (y i)))) -> f x = f y)
      : R =>
      \case Quotient.liftArray {n} {\lam _ => Term c} (\lam t t' => ~ {ProvableEqualCongruence T} t t') (\lam _ => ~-reflexive {ProvableEqualCongruence T}) args \with {
        | in~ a => f a
        | ~-equiv x y h => \case truncPArray {n} h \with {
          | inP h' => e h'
        }
      }

    \func funOfIn~ {_ : Language} {c : Context} {T : Theory c} {f : Functions} {args : Array (Term c) (funArity f)}
      : fun {structure {TermInterpretation T}} f (\lam i => in~ (args i)) = in~ (apply f args) => {?}

    \func termsAre~ {_ : Language} {c : Context} {T : Theory c} (t : Term c)
      : Interpretation.evaluate (TermInterpretation T) t = in~ t
    \elim t
      | var v => idp
      | apply f args =>
        \let
          | p : (\lam i => Interpretation.evaluate (TermInterpretation T) (args i)) =
          (\lam i => in~ (args i))
          => ext (\lam i => termsAre~ (args i))

          | p' : Quotient.liftArray (\lam {_} => ~ {ProvableEqualCongruence T}) (\lam {_} _ => ~-reflexive {ProvableEqualCongruence T}) (\lam i => in~ (args i))
            = {Quotient {DArray {funArity f} (\lam _ => Term c)} (\lam t t' => \Pi (j : Fin (funArity f)) -> t j ~ t' j)} in~ args => liftArrayElim

          | goal : (\case Quotient.liftArray (\lam {_} => ~) (\lam {_} _ => ~-reflexive) (\lam i => Interpretation.evaluate (TermInterpretation T) (args i)) \with {
            | in~ a => in~ (apply f a)
            | ~-equiv x y r i =>
              (\case truncPArray (\new DArray (\lam (j : Fin (funArity {Interpretation.L {TermInterpretation T}} f)) => x j ~ y j) r) \with {
                | inP r' => path (~-equiv (apply f x) (apply f y) (inP (fcong r' idp idp)))
              }) @ i
          }) = in~ (apply f args) =>
            run {transportInv
                     (\lam z => (\case Quotient.liftArray (\lam {_} => ~) (\lam {_} _ => ~-reflexive) z \with {
                       | in~ a => in~ (apply f a)
                       | ~-equiv x y r i =>
                         (\case truncPArray (\new DArray (\lam (j : Fin (funArity {Interpretation.L {TermInterpretation T}} f)) => x j ~ y j) r) \with {
                           | inP r' => path (~-equiv (apply f x) (apply f y) (inP (fcong r' idp idp)))
                         }) @ i
                     }) = in~ (apply f args))
                     p,
                 transportInv
                     (\lam z => (\case z \with {
                       | in~ a => in~ (apply f a)
                       | ~-equiv x y r i =>
                         (\case truncPArray (\new DArray (\lam (j : Fin (funArity {Interpretation.L {TermInterpretation T}} f)) => x j ~ y j) r) \with {
                           | inP r' => path (~-equiv (apply f x) (apply f y) (inP (fcong r' idp idp)))
                         }) @ i
                     }) = in~ (apply f args))
                     p',
                 idp
            }
        \in unfold goal

    \func isModelForEqual {_ : Language} {c : Context} {T : Theory c} {t t' : Term c}
      : (TermInterpretation T) ⊧ (equal t t') <-> Prf' T (equal t t') =>
      (\lam p => Quotient.equalityEquiv _ $ inv (termsAre~ t) *> p *> termsAre~ t',
       \lam p => termsAre~ t *> path (~-equiv t t' p) *> inv (termsAre~ t'))

    \func isModelForAtomic {_ : Language} {c : Context} {T : Theory c} {r : Relations} {args : Array (Term c) (relArity r)}
      : (TermInterpretation T) ⊧ (atomic r args) <--> Prf T (atomic r args) =>
      (\lam m => {?},
       \lam prf =>
           \let
             | h : rel {structure {TermInterpretation T}} r (\lam i => in~ (args i)) => unfold {?}

             | goal : rel {structure {TermInterpretation T}} r (\lam i => Interpretation.evaluate (TermInterpretation T) (args i)) =>
               transport
                   (\lam z => rel {structure {TermInterpretation T}} r z)
                   {\lam i => in~ (args i)} {\lam i => Interpretation.evaluate (TermInterpretation T) (args i)}
                   (ext (\lam i => inv $ termsAre~ (args i)))
                   h
           \in goal)
  }